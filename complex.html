<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ BFS Code</title>
    <!-- Include Highlight.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>
<body>
    <h1>C++ BFS Algorithm Code</h1>

    <p>The following code implements the <strong>Breadth-First Search (BFS)</strong> algorithm. This algorithm is especially useful for exploring a graph or a network of connected entities. In this case, we're using BFS to explore the connections between stores in a mall or shopping complex.</p>

    <p><strong>Why we are using BFS:</strong></p>
    <ul>
        <li><strong>Level-order traversal:</strong> BFS explores nodes level by level. This is useful when we want to explore all stores near the entrance before moving on to stores further away, as in the case of navigating through a shopping mall.</li>
        <li><strong>Shortest path in unweighted graphs:</strong> BFS guarantees finding the shortest path between two nodes if all edges have equal weight or cost. For example, if we wanted to find the shortest path from one store to another, BFS would be a great choice.</li>
        <li><strong>Optimal for finding all reachable nodes:</strong> BFS efficiently visits all reachable nodes, which is useful for applications where we want to explore all possible stores (or nodes) starting from a particular point (like the mall entrance).</li>
    </ul>

    <h2>Code Implementation:</h2>
    <pre><code class="cpp">
#include <iostream>
#include <queue>
#include <unordered_set>
#include <vector>

using namespace std;

void bfs(const vector<vector<int>>& graph, int start) {
    queue<int> q;
    unordered_set<int> visited;
    visited.insert(start);
    q.push(start);

    while (!q.empty()) {
        int node = q.front();
        q.pop();
        cout << "Visiting store " << node << endl;

        for (int neighbor : graph[node]) {
            if (visited.find(neighbor) == visited.end()) {
                visited.insert(neighbor);
                q.push(neighbor);
            }
        }
    }
}

int main() {
    vector<vector<int>> graph = {
        {1, 2}, // Store 0 is connected to 1, 2
        {0, 3}, // Store 1 is connected to 0, 3
        {0, 3}, // Store 2 is connected to 0, 3
        {1, 2}  // Store 3 is connected to 1, 2
    };

    bfs(graph, 0); // Start BFS from store 0 (entrance)

    return 0;
}
    </code></pre>

    <p><strong>Explanation of the Code:</strong></p>
    <ul>
        <li>The graph is represented using an adjacency list. Each store is represented as a node, and connections between stores are represented as edges in the graph.</li>
        <li>The BFS function uses a queue to explore each store, ensuring that we visit each store level by level.</li>
        <li>The <code>visited</code> set keeps track of stores that have already been visited to avoid revisiting the same store.</li>
        <li>The program starts the BFS search from store 0 (the entrance) and explores all connected stores.</li>
    </ul>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bellman-Ford Algorithm in C++</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        h1 {
            color: #4CAF50;
        }
        pre {
            background-color: #282c34;
            color: white;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-size: 16px;
            line-height: 1.6;
        }
        code {
            font-family: "Courier New", monospace;
        }
        .content {
            max-width: 1000px;
            margin: 0 auto;
        }
        footer {
            text-align: center;
            margin-top: 30px;
            font-size: 14px;
            color: #555;
        }
    </style>
</head>
<body>

    <div class="content">
        <h1>Bellman-Ford Algorithm in C++ for Accessing Safe Housing and Transportation</h1>
        <p>This example demonstrates how the Bellman-Ford algorithm can be used to find the shortest path between different residential areas and transportation hubs in a city layout. The algorithm is implemented in C++ and uses a graph-based model.</p>

        <h2>Code Implementation:</h2>
        <pre>
<code>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;climits&gt;
using namespace std;

class Graph {
public:
    int V, E;
    vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edges;

    Graph(int V, int E);
    void addEdge(int u, int v, int weight);
    void bellmanFord(int source);
};

Graph::Graph(int V, int E) {
    this-&gt;V = V;
    this-&gt;E = E;
}

void Graph::addEdge(int u, int v, int weight) {
    edges.push_back(make_pair(u, make_pair(v, weight)));
}

void Graph::bellmanFord(int source) {
    vector&lt;int&gt; dist(V, INT_MAX);
    dist[source] = 0;

    for (int i = 1; i &lt; V; i++) {
        for (auto edge : edges) {
            int u = edge.first;
            int v = edge.second.first;
            int weight = edge.second.second;
            if (dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) {
                dist[v] = dist[u] + weight;
            }
        }
    }

    for (auto edge : edges) {
        int u = edge.first;
        int v = edge.second.first;
        int weight = edge.second.second;
        if (dist[u] != INT_MAX &amp;&amp; dist[u] + weight &lt; dist[v]) {
            cout &lt;&lt; "Graph contains negative weight cycle\n";
            return;
        }
    }

    cout &lt;&lt; "Shortest distances from source " &lt;&lt; source &lt;&lt; ":\n";
    for (int i = 0; i &lt; V; i++) {
        if (dist[i] == INT_MAX) {
            cout &lt;&lt; "Node " &lt;&lt; i &lt;&lt; " is unreachable\n";
        } else {
            cout &lt;&lt; "Distance to node " &lt;&lt; i &lt;&lt; ": " &lt;&lt; dist[i] &lt;&lt; endl;
        }
    }
}

int main() {
    Graph g(6, 9);

    g.addEdge(0, 1, 4);
    g.addEdge(0, 2, 1);
    g.addEdge(2, 1, 2);
    g.addEdge(1, 3, 5);
    g.addEdge(2, 3, 8);
    g.addEdge(3, 4, 3);
    g.addEdge(4, 5, 6);
    g.addEdge(5, 3, 2);
    g.addEdge(3, 5, 7);

    g.bellmanFord(0);

    return 0;
}
</code>
        </pre>

        <footer>
            <p>&copy; 2024 Bellman-Ford Algorithm Example</p>
        </footer>
    </div>
</body>
</html>
